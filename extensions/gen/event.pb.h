// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: event.proto

#ifndef PROTOBUF_event_2eproto__INCLUDED
#define PROTOBUF_event_2eproto__INCLUDED

#include <string>

#include "extensions/google/protobuf/stubs/common.h"

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "extensions/google/protobuf/generated_message_util.h"
#include "extensions/google/protobuf/message_lite.h"
#include "extensions/google/protobuf/repeated_field.h"
#include "extensions/google/protobuf/extension_set.h"
// @@protoc_insertion_point(includes)

namespace nwapi {
namespace protocol {

extern const std::string* kEmptyString;

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_event_2eproto();
void protobuf_AssignDesc_event_2eproto();
void protobuf_ShutdownFile_event_2eproto();

class KeyEvent;
class TextEvent;
class MouseEvent;
class ClipboardEvent;

enum KeyEvent_LockStates {
  KeyEvent_LockStates_LOCK_STATES_CAPSLOCK = 1,
  KeyEvent_LockStates_LOCK_STATES_NUMLOCK = 2
};
bool KeyEvent_LockStates_IsValid(int value);
const KeyEvent_LockStates KeyEvent_LockStates_LockStates_MIN = KeyEvent_LockStates_LOCK_STATES_CAPSLOCK;
const KeyEvent_LockStates KeyEvent_LockStates_LockStates_MAX = KeyEvent_LockStates_LOCK_STATES_NUMLOCK;
const int KeyEvent_LockStates_LockStates_ARRAYSIZE = KeyEvent_LockStates_LockStates_MAX + 1;

enum MouseEvent_MouseButton {
  MouseEvent_MouseButton_BUTTON_UNDEFINED = 0,
  MouseEvent_MouseButton_BUTTON_LEFT = 1,
  MouseEvent_MouseButton_BUTTON_MIDDLE = 2,
  MouseEvent_MouseButton_BUTTON_RIGHT = 3,
  MouseEvent_MouseButton_BUTTON_MAX = 4
};
bool MouseEvent_MouseButton_IsValid(int value);
const MouseEvent_MouseButton MouseEvent_MouseButton_MouseButton_MIN = MouseEvent_MouseButton_BUTTON_UNDEFINED;
const MouseEvent_MouseButton MouseEvent_MouseButton_MouseButton_MAX = MouseEvent_MouseButton_BUTTON_MAX;
const int MouseEvent_MouseButton_MouseButton_ARRAYSIZE = MouseEvent_MouseButton_MouseButton_MAX + 1;

// ===================================================================

class KeyEvent : public ::google::protobuf::MessageLite {
 public:
  KeyEvent();
  virtual ~KeyEvent();

  KeyEvent(const KeyEvent& from);

  inline KeyEvent& operator=(const KeyEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const KeyEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KeyEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KeyEvent* other);

  // implements Message ----------------------------------------------

  KeyEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeyEvent& from);
  void MergeFrom(const KeyEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef KeyEvent_LockStates LockStates;
  static const LockStates LOCK_STATES_CAPSLOCK = KeyEvent_LockStates_LOCK_STATES_CAPSLOCK;
  static const LockStates LOCK_STATES_NUMLOCK = KeyEvent_LockStates_LOCK_STATES_NUMLOCK;
  static inline bool LockStates_IsValid(int value) {
    return KeyEvent_LockStates_IsValid(value);
  }
  static const LockStates LockStates_MIN =
    KeyEvent_LockStates_LockStates_MIN;
  static const LockStates LockStates_MAX =
    KeyEvent_LockStates_LockStates_MAX;
  static const int LockStates_ARRAYSIZE =
    KeyEvent_LockStates_LockStates_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bool pressed = 2;
  inline bool has_pressed() const;
  inline void clear_pressed();
  static const int kPressedFieldNumber = 2;
  inline bool pressed() const;
  inline void set_pressed(bool value);

  // optional uint32 usb_keycode = 3;
  inline bool has_usb_keycode() const;
  inline void clear_usb_keycode();
  static const int kUsbKeycodeFieldNumber = 3;
  inline ::google::protobuf::uint32 usb_keycode() const;
  inline void set_usb_keycode(::google::protobuf::uint32 value);

  // optional uint32 lock_states = 4 [default = 0];
  inline bool has_lock_states() const;
  inline void clear_lock_states();
  static const int kLockStatesFieldNumber = 4;
  inline ::google::protobuf::uint32 lock_states() const;
  inline void set_lock_states(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nwapi.protocol.KeyEvent)
 private:
  inline void set_has_pressed();
  inline void clear_has_pressed();
  inline void set_has_usb_keycode();
  inline void clear_has_usb_keycode();
  inline void set_has_lock_states();
  inline void clear_has_lock_states();

  bool pressed_;
  ::google::protobuf::uint32 usb_keycode_;
  ::google::protobuf::uint32 lock_states_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_event_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_event_2eproto();
  #endif
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static KeyEvent* default_instance_;
};
// -------------------------------------------------------------------

class TextEvent : public ::google::protobuf::MessageLite {
 public:
  TextEvent();
  virtual ~TextEvent();

  TextEvent(const TextEvent& from);

  inline TextEvent& operator=(const TextEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const TextEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextEvent* other);

  // implements Message ----------------------------------------------

  TextEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextEvent& from);
  void MergeFrom(const TextEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:nwapi.protocol.TextEvent)
 private:
  inline void set_has_text();
  inline void clear_has_text();

  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_event_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_event_2eproto();
  #endif
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static TextEvent* default_instance_;
};
// -------------------------------------------------------------------

class MouseEvent : public ::google::protobuf::MessageLite {
 public:
  MouseEvent();
  virtual ~MouseEvent();

  MouseEvent(const MouseEvent& from);

  inline MouseEvent& operator=(const MouseEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const MouseEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MouseEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MouseEvent* other);

  // implements Message ----------------------------------------------

  MouseEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MouseEvent& from);
  void MergeFrom(const MouseEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MouseEvent_MouseButton MouseButton;
  static const MouseButton BUTTON_UNDEFINED = MouseEvent_MouseButton_BUTTON_UNDEFINED;
  static const MouseButton BUTTON_LEFT = MouseEvent_MouseButton_BUTTON_LEFT;
  static const MouseButton BUTTON_MIDDLE = MouseEvent_MouseButton_BUTTON_MIDDLE;
  static const MouseButton BUTTON_RIGHT = MouseEvent_MouseButton_BUTTON_RIGHT;
  static const MouseButton BUTTON_MAX = MouseEvent_MouseButton_BUTTON_MAX;
  static inline bool MouseButton_IsValid(int value) {
    return MouseEvent_MouseButton_IsValid(value);
  }
  static const MouseButton MouseButton_MIN =
    MouseEvent_MouseButton_MouseButton_MIN;
  static const MouseButton MouseButton_MAX =
    MouseEvent_MouseButton_MouseButton_MAX;
  static const int MouseButton_ARRAYSIZE =
    MouseEvent_MouseButton_MouseButton_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional .nwapi.protocol.MouseEvent.MouseButton button = 5;
  inline bool has_button() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 5;
  inline ::nwapi::protocol::MouseEvent_MouseButton button() const;
  inline void set_button(::nwapi::protocol::MouseEvent_MouseButton value);

  // optional bool button_down = 6;
  inline bool has_button_down() const;
  inline void clear_button_down();
  static const int kButtonDownFieldNumber = 6;
  inline bool button_down() const;
  inline void set_button_down(bool value);

  // optional float wheel_delta_x = 7;
  inline bool has_wheel_delta_x() const;
  inline void clear_wheel_delta_x();
  static const int kWheelDeltaXFieldNumber = 7;
  inline float wheel_delta_x() const;
  inline void set_wheel_delta_x(float value);

  // optional float wheel_delta_y = 8;
  inline bool has_wheel_delta_y() const;
  inline void clear_wheel_delta_y();
  static const int kWheelDeltaYFieldNumber = 8;
  inline float wheel_delta_y() const;
  inline void set_wheel_delta_y(float value);

  // optional float wheel_ticks_x = 9;
  inline bool has_wheel_ticks_x() const;
  inline void clear_wheel_ticks_x();
  static const int kWheelTicksXFieldNumber = 9;
  inline float wheel_ticks_x() const;
  inline void set_wheel_ticks_x(float value);

  // optional float wheel_ticks_y = 10;
  inline bool has_wheel_ticks_y() const;
  inline void clear_wheel_ticks_y();
  static const int kWheelTicksYFieldNumber = 10;
  inline float wheel_ticks_y() const;
  inline void set_wheel_ticks_y(float value);

  // optional int32 delta_x = 11;
  inline bool has_delta_x() const;
  inline void clear_delta_x();
  static const int kDeltaXFieldNumber = 11;
  inline ::google::protobuf::int32 delta_x() const;
  inline void set_delta_x(::google::protobuf::int32 value);

  // optional int32 delta_y = 12;
  inline bool has_delta_y() const;
  inline void clear_delta_y();
  static const int kDeltaYFieldNumber = 12;
  inline ::google::protobuf::int32 delta_y() const;
  inline void set_delta_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nwapi.protocol.MouseEvent)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_button();
  inline void clear_has_button();
  inline void set_has_button_down();
  inline void clear_has_button_down();
  inline void set_has_wheel_delta_x();
  inline void clear_has_wheel_delta_x();
  inline void set_has_wheel_delta_y();
  inline void clear_has_wheel_delta_y();
  inline void set_has_wheel_ticks_x();
  inline void clear_has_wheel_ticks_x();
  inline void set_has_wheel_ticks_y();
  inline void clear_has_wheel_ticks_y();
  inline void set_has_delta_x();
  inline void clear_has_delta_x();
  inline void set_has_delta_y();
  inline void clear_has_delta_y();

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  int button_;
  bool button_down_;
  float wheel_delta_x_;
  float wheel_delta_y_;
  float wheel_ticks_x_;
  float wheel_ticks_y_;
  ::google::protobuf::int32 delta_x_;
  ::google::protobuf::int32 delta_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_event_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_event_2eproto();
  #endif
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static MouseEvent* default_instance_;
};
// -------------------------------------------------------------------

class ClipboardEvent : public ::google::protobuf::MessageLite {
 public:
  ClipboardEvent();
  virtual ~ClipboardEvent();

  ClipboardEvent(const ClipboardEvent& from);

  inline ClipboardEvent& operator=(const ClipboardEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClipboardEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClipboardEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClipboardEvent* other);

  // implements Message ----------------------------------------------

  ClipboardEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClipboardEvent& from);
  void MergeFrom(const ClipboardEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mime_type = 1;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 1;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  inline ::std::string* release_mime_type();
  inline void set_allocated_mime_type(::std::string* mime_type);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:nwapi.protocol.ClipboardEvent)
 private:
  inline void set_has_mime_type();
  inline void clear_has_mime_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string* mime_type_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_event_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_event_2eproto();
  #endif
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static ClipboardEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// KeyEvent

// optional bool pressed = 2;
inline bool KeyEvent::has_pressed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyEvent::set_has_pressed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyEvent::clear_has_pressed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyEvent::clear_pressed() {
  pressed_ = false;
  clear_has_pressed();
}
inline bool KeyEvent::pressed() const {
  return pressed_;
}
inline void KeyEvent::set_pressed(bool value) {
  set_has_pressed();
  pressed_ = value;
}

// optional uint32 usb_keycode = 3;
inline bool KeyEvent::has_usb_keycode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyEvent::set_has_usb_keycode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyEvent::clear_has_usb_keycode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyEvent::clear_usb_keycode() {
  usb_keycode_ = 0u;
  clear_has_usb_keycode();
}
inline ::google::protobuf::uint32 KeyEvent::usb_keycode() const {
  return usb_keycode_;
}
inline void KeyEvent::set_usb_keycode(::google::protobuf::uint32 value) {
  set_has_usb_keycode();
  usb_keycode_ = value;
}

// optional uint32 lock_states = 4 [default = 0];
inline bool KeyEvent::has_lock_states() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyEvent::set_has_lock_states() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyEvent::clear_has_lock_states() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyEvent::clear_lock_states() {
  lock_states_ = 0u;
  clear_has_lock_states();
}
inline ::google::protobuf::uint32 KeyEvent::lock_states() const {
  return lock_states_;
}
inline void KeyEvent::set_lock_states(::google::protobuf::uint32 value) {
  set_has_lock_states();
  lock_states_ = value;
}

// -------------------------------------------------------------------

// TextEvent

// optional string text = 1;
inline bool TextEvent::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextEvent::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextEvent::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextEvent::clear_text() {
  if (text_ != kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TextEvent::text() const {
  return *text_;
}
inline void TextEvent::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextEvent::set_text(const char* value) {
  set_has_text();
  if (text_ == kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextEvent::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextEvent::mutable_text() {
  set_has_text();
  if (text_ == kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TextEvent::release_text() {
  clear_has_text();
  if (text_ == kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(kEmptyString);
    return temp;
  }
}
inline void TextEvent::set_allocated_text(::std::string* text) {
  if (text_ != kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(kEmptyString);
  }
}

// -------------------------------------------------------------------

// MouseEvent

// optional int32 x = 1;
inline bool MouseEvent::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MouseEvent::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MouseEvent::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MouseEvent::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MouseEvent::x() const {
  return x_;
}
inline void MouseEvent::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 2;
inline bool MouseEvent::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MouseEvent::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MouseEvent::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MouseEvent::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MouseEvent::y() const {
  return y_;
}
inline void MouseEvent::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional .nwapi.protocol.MouseEvent.MouseButton button = 5;
inline bool MouseEvent::has_button() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MouseEvent::set_has_button() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MouseEvent::clear_has_button() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MouseEvent::clear_button() {
  button_ = 0;
  clear_has_button();
}
inline ::nwapi::protocol::MouseEvent_MouseButton MouseEvent::button() const {
  return static_cast< ::nwapi::protocol::MouseEvent_MouseButton >(button_);
}
inline void MouseEvent::set_button(::nwapi::protocol::MouseEvent_MouseButton value) {
  assert(::nwapi::protocol::MouseEvent_MouseButton_IsValid(value));
  set_has_button();
  button_ = value;
}

// optional bool button_down = 6;
inline bool MouseEvent::has_button_down() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MouseEvent::set_has_button_down() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MouseEvent::clear_has_button_down() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MouseEvent::clear_button_down() {
  button_down_ = false;
  clear_has_button_down();
}
inline bool MouseEvent::button_down() const {
  return button_down_;
}
inline void MouseEvent::set_button_down(bool value) {
  set_has_button_down();
  button_down_ = value;
}

// optional float wheel_delta_x = 7;
inline bool MouseEvent::has_wheel_delta_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MouseEvent::set_has_wheel_delta_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MouseEvent::clear_has_wheel_delta_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MouseEvent::clear_wheel_delta_x() {
  wheel_delta_x_ = 0;
  clear_has_wheel_delta_x();
}
inline float MouseEvent::wheel_delta_x() const {
  return wheel_delta_x_;
}
inline void MouseEvent::set_wheel_delta_x(float value) {
  set_has_wheel_delta_x();
  wheel_delta_x_ = value;
}

// optional float wheel_delta_y = 8;
inline bool MouseEvent::has_wheel_delta_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MouseEvent::set_has_wheel_delta_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MouseEvent::clear_has_wheel_delta_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MouseEvent::clear_wheel_delta_y() {
  wheel_delta_y_ = 0;
  clear_has_wheel_delta_y();
}
inline float MouseEvent::wheel_delta_y() const {
  return wheel_delta_y_;
}
inline void MouseEvent::set_wheel_delta_y(float value) {
  set_has_wheel_delta_y();
  wheel_delta_y_ = value;
}

// optional float wheel_ticks_x = 9;
inline bool MouseEvent::has_wheel_ticks_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MouseEvent::set_has_wheel_ticks_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MouseEvent::clear_has_wheel_ticks_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MouseEvent::clear_wheel_ticks_x() {
  wheel_ticks_x_ = 0;
  clear_has_wheel_ticks_x();
}
inline float MouseEvent::wheel_ticks_x() const {
  return wheel_ticks_x_;
}
inline void MouseEvent::set_wheel_ticks_x(float value) {
  set_has_wheel_ticks_x();
  wheel_ticks_x_ = value;
}

// optional float wheel_ticks_y = 10;
inline bool MouseEvent::has_wheel_ticks_y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MouseEvent::set_has_wheel_ticks_y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MouseEvent::clear_has_wheel_ticks_y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MouseEvent::clear_wheel_ticks_y() {
  wheel_ticks_y_ = 0;
  clear_has_wheel_ticks_y();
}
inline float MouseEvent::wheel_ticks_y() const {
  return wheel_ticks_y_;
}
inline void MouseEvent::set_wheel_ticks_y(float value) {
  set_has_wheel_ticks_y();
  wheel_ticks_y_ = value;
}

// optional int32 delta_x = 11;
inline bool MouseEvent::has_delta_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MouseEvent::set_has_delta_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MouseEvent::clear_has_delta_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MouseEvent::clear_delta_x() {
  delta_x_ = 0;
  clear_has_delta_x();
}
inline ::google::protobuf::int32 MouseEvent::delta_x() const {
  return delta_x_;
}
inline void MouseEvent::set_delta_x(::google::protobuf::int32 value) {
  set_has_delta_x();
  delta_x_ = value;
}

// optional int32 delta_y = 12;
inline bool MouseEvent::has_delta_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MouseEvent::set_has_delta_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MouseEvent::clear_has_delta_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MouseEvent::clear_delta_y() {
  delta_y_ = 0;
  clear_has_delta_y();
}
inline ::google::protobuf::int32 MouseEvent::delta_y() const {
  return delta_y_;
}
inline void MouseEvent::set_delta_y(::google::protobuf::int32 value) {
  set_has_delta_y();
  delta_y_ = value;
}

// -------------------------------------------------------------------

// ClipboardEvent

// optional string mime_type = 1;
inline bool ClipboardEvent::has_mime_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClipboardEvent::set_has_mime_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClipboardEvent::clear_has_mime_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClipboardEvent::clear_mime_type() {
  if (mime_type_ != kEmptyString) {
    mime_type_->clear();
  }
  clear_has_mime_type();
}
inline const ::std::string& ClipboardEvent::mime_type() const {
  return *mime_type_;
}
inline void ClipboardEvent::set_mime_type(const ::std::string& value) {
  set_has_mime_type();
  if (mime_type_ == kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void ClipboardEvent::set_mime_type(const char* value) {
  set_has_mime_type();
  if (mime_type_ == kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void ClipboardEvent::set_mime_type(const char* value, size_t size) {
  set_has_mime_type();
  if (mime_type_ == kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClipboardEvent::mutable_mime_type() {
  set_has_mime_type();
  if (mime_type_ == kEmptyString) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}
inline ::std::string* ClipboardEvent::release_mime_type() {
  clear_has_mime_type();
  if (mime_type_ == kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mime_type_;
    mime_type_ = const_cast< ::std::string*>(kEmptyString);
    return temp;
  }
}
inline void ClipboardEvent::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type_ != kEmptyString) {
    delete mime_type_;
  }
  if (mime_type) {
    set_has_mime_type();
    mime_type_ = mime_type;
  } else {
    clear_has_mime_type();
    mime_type_ = const_cast< ::std::string*>(kEmptyString);
  }
}

// optional bytes data = 2;
inline bool ClipboardEvent::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClipboardEvent::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClipboardEvent::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClipboardEvent::clear_data() {
  if (data_ != kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ClipboardEvent::data() const {
  return *data_;
}
inline void ClipboardEvent::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ClipboardEvent::set_data(const char* value) {
  set_has_data();
  if (data_ == kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ClipboardEvent::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClipboardEvent::mutable_data() {
  set_has_data();
  if (data_ == kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ClipboardEvent::release_data() {
  clear_has_data();
  if (data_ == kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(kEmptyString);
    return temp;
  }
}
inline void ClipboardEvent::set_allocated_data(::std::string* data) {
  if (data_ != kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace nwapi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_event_2eproto__INCLUDED
